# 回溯

- [回溯](#回溯)
  - [回溯算法](#回溯算法)
  - [题目](#题目)
    - [【17. 电话号码的字母组合】](#17-电话号码的字母组合)
    - [【22. 括号生成】](#22-括号生成)
    - [【46. 全排列】](#46-全排列)
    - [【78. 子集】](#78-子集)
    - [【79. 单词搜索】](#79-单词搜索)
  
## 回溯算法

第一次完整地做回溯相关的题，感觉还是套路满满。解这类题要能很快地想出怎么样去构建回溯的函数，就像在模板里填内容一样。

## 题目

### 【17. 电话号码的字母组合】

比较简单的回溯题，可以作为一个回溯的模板题。

### 【22. 括号生成】

回溯函数除了常见的参数还会传入两个参数，分别是 left 和 right，用于维护回溯中的左括号和右括号数量。回溯过程中分别判断这两个数量，但判断条件不同，左括号数量不能超过 n，右括号数量不能多于左括号的数量。然后就进行普通回溯即可。

### 【46. 全排列】

这题可以和下面的子集这一题形成对比，在全排列里需要注意一个问题，元素是不能重复的。如果是用`vector<int>`类型的 tmp 来加入和删除元素，作为中间结果，那么就可能出现同一个位置的元素重复出现的情况。为了保证每个元素只出现一个，我们直接将原始的数组传入，回溯函数中会交换和恢复元素的位置的操作，从而得到一个新的排列。

### 【78. 子集】

可以有两种方法，位运算和回溯。位运算其实只要掌握之前总结的就能很快写出来，回溯的方法是非常基础的，这个题适合当做回溯的模板题。

### 【79. 单词搜索】

在二维的 board 里搜索出指定的单词，单词需要按照顺序且在相邻的单元格中构成。这一题还是有一点难度的，我直接参考题解的思路了。每次考虑单元格每次回溯要在相邻的位置（更新 i,j 再传入回溯函数），而且需要保证在同一次回溯的时候，不能访问已经访问过的单元格。