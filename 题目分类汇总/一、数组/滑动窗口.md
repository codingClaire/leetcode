# 滑动窗口
- [滑动窗口](#滑动窗口)
  - [滑动窗口模板](#滑动窗口模板)
  - [滑动窗口题目](#滑动窗口题目)
    - [【3.无重复字符的最长子串】](#3无重复字符的最长子串)
    - [【76. 最小覆盖子串】](#76-最小覆盖子串)
    - [【209.长度最小的子数组】](#209长度最小的子数组)
    - [【239. 滑动窗口最大值】](#239-滑动窗口最大值)
    - [【283.移动零】](#283移动零)
    - [【1004.最大连续 1 的个数 III】](#1004最大连续-1-的个数-iii)

## 滑动窗口模板

```c++
int findSubset(vector<int> &nums, int k)
{
    int n = nums.size();
    int start = 0, end = 0; //双指针，当前遍历的区间为[start, end]
    int sums = 0;           //用于统计子数组/子区间是否有效，根据题目可能会改成求和/计数
    int res = 0;            //保存最大的满足题目要求的 子数组/子串 长度
    while (end < n)
    {
        //当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[end]; //增加当前右边指针的数字/字符的求和/计数
        while (a)
        {
            // a表示区间[start,end]不符合题目给定条件
            //需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[start]; //移动左指针前需要从nums中减少start位置字符的求和/计数
            start++;             //移动左指针，注意不能跟上面一行代码写反
        }
        //找到了一个符合题意要求的子数组/子串
        res = max(res, end - start + 1); //更新维护的最小/最大的结果
        end++;                           //移动右指针，探索新的区间
    }
    return res;
}
```

## 滑动窗口题目

### 【3.无重复字符的最长子串】

### 【76. 最小覆盖子串】

### 【209.长度最小的子数组】

### 【239. 滑动窗口最大值】

### 【283.移动零】

把数组的所有的 0 放到数组最后。我的解法：遍历一边数组，一遍找 0 一边删除，然后统计 0 的个数，并最后添加相应数量的 0，这个解法不够快。看了一下题解，自己写了一个双指针的方法：初始两个指针都指向第一个元素，然后左边的指针始终指向排好顺序的数组的下一个数（可能是 0，也可能不是）。右指针用来探索当前的数是不是 0。如果不是 0，那么就和左指针指向的元素交换（如果左指针指向的不是 0，那么这个情况只能说明目前还没有 0 找到，那么右指针肯定是和左指针指向的是同一个数，所以不影响），然后再右移左右指针，直到右指针找到最后一个数。


### 【1004.最大连续 1 的个数 III】

- 【2104（周赛）】
