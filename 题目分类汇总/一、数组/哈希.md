# 哈希
- [哈希](#哈希)
  - [题目](#题目)
    - [【1.两数之和】](#1两数之和)
    - [【189. 轮转数组】](#189-轮转数组)
    - [【217. 存在重复元素】](#217-存在重复元素)
    - [【350.两个数组的交集-II】](#350两个数组的交集-ii)
## 题目

### 【1.两数之和】

给定 target，求满足和为 target 的两个数的 index。用一个`unordered_map<int, int>`记录剩余数值和对应的已取元素的 index。然后遍历一次数组，如果当前 index 的数取了之后，剩余部分能够在哈希表的键中中找到，那么就知道两个数分别是当前 index 和哈希表相应的 index 值。如果找不到的话，就把当前的 index 的数值作为键，index 作为值，存储进哈希表中。这个解法比暴力显然是更好的，时空复杂度都是 O(N)。

### 【189. 轮转数组】

给定 k，确定向右轮转 k 步的数组。1）哈希法：构建一个新的数组，这个数组的第`(i + k) % nums.size()`个元素就是原始数组的第 i 个元素，类似哈希的算法。比如原始第 0 个会向右走`k % nums.size()`步，比较优雅巧妙的做法了。 2）翻转法：首先`k %= nums.size()`，因为如果 k 大于数组长度，会轮转到原始的数组，所以把余数赋给 k 就行。然后一个经典的两只手翻转法，先整个翻转数组，然后翻转前 k-1 个，再翻转 k 到最后一个。这样就能够得到一个轮转 k 次的数组了。


### 【217. 存在重复元素】

简单题，两种方法：1)使用一个`unordered_set<int>`来记录出现过的数字，注意这里要用 unordered_set 才会快，如果用 set 会自动排序，时间消耗会大。2）先把数组排序，如果当前数等于下一个数，那么就返回有重复。

### 【350.两个数组的交集-II】

计算两个数组的交集。用一个哈希表`unordered_map<int, int>`来记录第一个数组的数字出现的次数，然后再遍历第二个数组，如果是在哈希表中的数字的话，那么就加入最终的结果数组中，并更新哈希表。
