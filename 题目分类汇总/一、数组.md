# 一、数组 🔢

- [一、数组 🔢](#一数组-)
  - [简单模拟](#简单模拟)
  - [贪心](#贪心)
  - [滑动窗口](#滑动窗口)
    - [滑动窗口模板](#滑动窗口模板)
    - [滑动窗口题目](#滑动窗口题目)
      - [【3.无重复字符的最长子串】](#3无重复字符的最长子串)
      - [【76. 最小覆盖子串】](#76-最小覆盖子串)
      - [【209.长度最小的子数组】](#209长度最小的子数组)
      - [【239. 滑动窗口最大值】](#239-滑动窗口最大值)
      - [【1004.最大连续 1 的个数 III】](#1004最大连续-1-的个数-iii)
  - [双指针](#双指针)
    - [双指针题目](#双指针题目)
      - [【19.删除链表的倒数第 N 个结点】](#19删除链表的倒数第-n-个结点)
      - [【26.删除有序数组中的重复项】](#26删除有序数组中的重复项)
      - [【88.合并两个有序数组】](#88合并两个有序数组)
      - [【125.验证回文串】](#125验证回文串)
      - [【234.回文链表】](#234回文链表)
      - [【344.反转字符串】](#344反转字符串)
  - [随机数组](#随机数组)
    - [随机数组题目](#随机数组题目)
      - [【384.打乱数组】](#384打乱数组)


## 简单模拟

## 贪心

## 滑动窗口

### 滑动窗口模板

```c++
int findSubset(vector<int> &nums, int k)
{
    int n = nums.size();
    int start = 0, end = 0; //双指针，当前遍历的区间为[start, end]
    int sums = 0;           //用于统计子数组/子区间是否有效，根据题目可能会改成求和/计数
    int res = 0;            //保存最大的满足题目要求的 子数组/子串 长度
    while (end < n)
    {
        //当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[end]; //增加当前右边指针的数字/字符的求和/计数
        while (a)
        {
            // a表示区间[start,end]不符合题目给定条件
            //需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[start]; //移动左指针前需要从nums中减少start位置字符的求和/计数
            start++;             //移动左指针，注意不能跟上面一行代码写反
        }
        //找到了一个符合题意要求的子数组/子串
        res = max(res, end - start + 1); //更新维护的最小/最大的结果
        end++;                           //移动右指针，探索新的区间
    }
    return res;
}
```

### 滑动窗口题目

#### 【3.无重复字符的最长子串】

#### 【76. 最小覆盖子串】

#### 【209.长度最小的子数组】

#### 【239. 滑动窗口最大值】

#### 【1004.最大连续 1 的个数 III】

- 【2104（周赛）】

## 双指针

### 双指针题目

#### 【19.删除链表的倒数第 N 个结点】

#### 【26.删除有序数组中的重复项】

#### 【88.合并两个有序数组】

#### 【125.验证回文串】

#### 【234.回文链表】

#### 【344.反转字符串】

## 随机数组

### 随机数组题目

#### 【384.打乱数组】

洗牌算法典型题。
