# LeetBook 中级算法

2022.05.30 开始做 LeetBook 中级算法，每周争取一个章节。

<!-- TOC -->

- [LeetBook 中级算法](#leetbook-中级算法)
  - [数组和字符串](#数组和字符串)
    - [【15. 三数之和】](#15-三数之和)
    - [【73. 矩阵置零】](#73-矩阵置零)
    - [【49. 字母异位词分组】](#49-字母异位词分组)
    - [【3. 无重复字符的最长子串】](#3-无重复字符的最长子串)
    - [【5. 最长回文子串】](#5-最长回文子串)
    - [【334. 递增的三元子序列】](#334-递增的三元子序列)
  - [链表](#链表)
    - [【2.两数相加】](#2两数相加)
    - [【328.奇偶链表】](#328奇偶链表)
    - [【160.相交链表】](#160相交链表)
  - [树和图](#树和图)
    - [【94. 二叉树的中序遍历】](#94-二叉树的中序遍历)
    - [【103. 二叉树的锯齿形层次遍历】](#103-二叉树的锯齿形层次遍历)
    - [【105. 从前序与中序遍历序列构造二叉树】](#105-从前序与中序遍历序列构造二叉树)
    - [【116. 填充每个节点的下一个右侧节点指针】](#116-填充每个节点的下一个右侧节点指针)
    - [【230. 二叉搜索树中第 K 小的元素】](#230-二叉搜索树中第-k-小的元素)
    - [【200. 岛屿数量】](#200-岛屿数量)
  - [回溯算法](#回溯算法)
  - [排序和搜索](#排序和搜索)
  - [动态规划](#动态规划)
  - [设计问题](#设计问题)
  - [数学](#数学)
  - [其他](#其他)

<!-- /TOC -->

## 数组和字符串

### 【15. 三数之和】

经典面试题了，找不重复且和为 0 的三元组。不重复就可以先排序，然后枚举的数是越来越大的。第一个数按顺序枚举，然后找剩下的两个数加起来等于第一个数的相反数（target）的解。第三个数起始位置在排序后的数组列表末尾，在保证第三个数不小于第二个数的时候，逐渐缩小范围。如果两个数重合，那么就舍弃解，如果能找到等于 target 的第二和第三个不重复的数，就添加进解数组中。

### 【73. 矩阵置零】

把矩阵的存在 0 的行和列都置零，这里一开始我还在想这么简单为什么还算 medium，结果是因为我脑子里第一反应就是直接遍历，但是这会在更新时有问题，因为会影响后续的 0 的存在判断。所以，官方题解给出了两种思路，空间复杂度分别是 O(m+n)和 O(1)。
前一种是使用两个一维的标记数组分别记录行和列的零的出现情况，后一种是直接用两个标记变量存储数组的第一行和第一列含 0 的情况，然后再用原矩阵的第一列和第一行来代替前一个方法的标记数组。再优化后一种方法就用一个标记变量记录第一列是否含零，然后第一列的第一个元素就可以标记第一行是否含零了，但是这里需要从最后一行来倒序处理矩阵元素防止提前更新。

### 【49. 字母异位词分组】

异位词包含的字母和字母的数量均相同，第一种方法是先排序字符串中的字符，然后用字符排序后形成的字符串作为哈希值，从而确定字母异位词。我的思路和第一个很像，但是我忘记了 string 就是字符的数组，可以直接用`sort(str.begin(),str.end())`，还非常费劲地自己写了一个哈希，搞得时间非常慢。
第二种方法使用相同字母出现的次数用字符串表示作为哈希值，这种方法的官方题解 C++版本过于高深，推荐啃一下，会 get 到很多新知识和语法。

### 【3. 无重复字符的最长子串】

滑动窗口经典题，建议全文背诵（不是），这题只需要求最长子串的长度，和下一题可以形成对比。
第一种是官方题解的思路。用一个 unordered_set 来存储`[left,right]`的字符，随着 left 的遍历，这个集合会不断舍弃最左边的元素。然后不断右移右指针，直到`right+1`的字符出现在集合中，然后更新 ans，取当前 ans 和 right-left-1 较大的一方。这里值得注意的 right 的初始化，是从-1 开始，判断 right+1，这样 right 指向的就是重复元素的前一个元素，保证`[left,right]`没有重复元素。
第二种做法是用 unordered_map 来存储字符和对应的位置，这里也是一种双指针的思想，从零开始遍历右指针，如果右指针指向的值存在在 map 中，那么就更新左指针，向右移动到右指针所在位置的下一个指针。然后插入右指针键值对，并更新长度。

### 【5. 最长回文子串】

求数组的最长回文子串。
用动态规划，初始化一个 n\*n 的二维数组，其中`dp[i][i]`为真（只有一个字符的字符串显然是回文串）。首先遍历回文串的长度，然后对每个长度`len`，遍历左侧的位置`left`，同时计算出右侧结束的位置`left+len-1`。如果右侧位置超过 n，那么直接 break；否则判断`s[left]`和`s[right]`的关系：如果不相等，那么`dp[left][right]`的布尔值为 false，如果相等，那么如果回文串长度小于四的话，那么就为真（长度为 3 和 2 都满足）；否则，`dp[left][right]`和`dp[left+1][right-1]`相同（根据状态转移方程得出）。每一步更新 dp 的时候，顺便就存储最长的子串和起始位置。
另一种方法和动态规划类似，就是遍历每一个字符，然后分别以奇数和偶数的回文子串来进行扩展。

### 【334. 递增的三元子序列】

第一种做法：两次遍历。设计两个数组 leftmin 和 rightmax，分别从数组开始和末尾进行遍历。`leftmin[i]`表示原数组中第 i 个数的左侧最小的数，`rightmax[i]`表示元素组中第 i 个数的右侧最大的数。然后再次遍历，对第 i 个数组，如果有`leftmin[i]<nums[i]<rightmax[i]`，那么就返回 true，如果没有就返回 false。但这个方法的时间复杂度为 O(n)，空间复杂度也为 O(n)。
第二种做法：贪心。贪心的主要思想就是尽可能地使得 first 和 second 小，这样使得找到递增三元子序列的可能性更大。先令 first 为数组的第一个元素，second 为 INT_MAX。从第二个元素开始遍历数组，如果当前元素大于 second，那么序列找到，直接返回 true，否则判断当前的元素和 first 的关系，如果大于 first，那么就更新 second 的值为当前元素，反之则更新 first 的值为当前元素。这个思路很简洁，值得学习。

## 链表

中级的链表题略有难度，这几题都很经典。

### 【2.两数相加】

逆序的存储数字数位的链表相加，需要考虑金文问题，特别是遍历结束后的进位也需要注意。两个链表不等长的情况，可以每次循环判断，如果已经是 null 的话就直接把当前节点的值记为 0 即可。接着判断是否头节点指向 null（第一个节点的情况），如果是的话就将新建一个节点，将头尾节点都指向它；否则尾节点指向的下一个节点是这个新的节点，并更新尾节点。

### 【328.奇偶链表】

链表奇数节点全部放前面，偶数节点全部放后面。奇数链表的头节点：`head`，偶数链表的头节点：`even Head= head->next`。两个指针分别指向奇数节点（`odd`）和偶数节点（`even`），当偶数链表的节点不为空且指向的节点不为空时，分别进行如下操作：

1） 奇数指针指向的节点的下一个节点指向下个奇数节点（`odd->next = even->next`）。 2) 奇数指针指向的节点更新到下一个奇数节点上（`odd = odd->next`）。 3) 偶数节点的下一个节点指向下下个偶数节点（`even->next = odd->next`），这里用`odd->next`表示下下个节点，因为`odd`已经在第二步更新了。 4) 偶数指针指向的节点更新到下一个偶数节点上（`even = even->next`）。

`while`循环结束后，当前的 odd 停在最后一个奇数上，将它指向`evenHead`，就将偶数节点挪到所有的奇数节点之后了。

### 【160.相交链表】

有两种方法，一种是用元素为`ListNode*`的哈希集合来存储出现过的指针，显然空间复杂度较高，因为哈希集合所需要的存储空间较多，第二种是用双指针，官方题解里非常巧妙的一种做法，把空间复杂度降到`O(1)`，感觉和那个判断链表里有没有环的题有异曲同工之妙。两个指针从两个链表开始循环，如果循环完了还没有找到的话，就赋值到另一个链表的 head，这样如果有交点，那么肯定能在一个时刻发现两个链表指向同一个节点（看题解立马就懂了），而如果没有交点的话，两个指针都会指向 null。非常妙的做法。

## 树和图

### 【94. 二叉树的中序遍历】

中序遍历也有好几种做法呀，我只会递归的方法。还可以用的方法包括栈迭代和 Morris 中序遍历，后者可以把空间复杂度降为 O(1)。时间缘故，就不细致地讲算法了，后续再整理。

### 【103. 二叉树的锯齿形层次遍历】

层次遍历的框架，加上双端队列来处理反向顺序的遍历。但是看了评论，说的是实际上这样并不能满足不同方向的遍历的要求，所以也可以 BFS 的时候直接用双端队列来分别处理两种方向的遍历。

### 【105. 从前序与中序遍历序列构造二叉树】

这题刚开始看有点懵，看了题解以后就马上能反应过来了。核心点就是用中序遍历来确定每次根节点左子树和右子树的节点数量，这需要每次在中序遍历中定位到根节点（这里可以用哈希表提前存储中序的节点值和位置的对应关系）。递归函数会每次构造左子树和右子树，除了前序和中序的原始序列，还需要相应的开始和结束的位置。

### 【116. 填充每个节点的下一个右侧节点指针】

这题还是层次遍历的套路，只需要每次层次遍历时将当前节点的 next 指针更新到队列的下一个节点即可。另一个想法是直接考虑每一层的节点应该怎么链接，分为两种情况，链接同一个父节点的和在不同的父节点的。实际上也并不难，只需要在已经建立 next 关系的当前层，更新下一层的 next 关系即可。每次沿着左侧更新 leftmost，每次 leftmost 都指向当前层的第一个节点。

### 【230. 二叉搜索树中第 K 小的元素】

取中序遍历之后得到序列的第 K-1 个即可。还可以按照一种类似二分的做法，每次记录求左子树和右子树的个数，如果大于左子树，那么这个数就在右子树中，否则在左子树中。也可以像题解那样，手写平衡二叉搜索树（长度过于离谱了）。

### 【200. 岛屿数量】

经典题，可以用深度或广度优先搜索，扫描整个二维网格，在搜索的过程中不断把 1 置为 0。最后的次数恰好就是深度或广度优先搜索执行的次数。还可以考虑并查集，也很巧妙。

## 回溯算法

电话号码的字母组合
括号生成
全排列
子集
单词搜索

## 排序和搜索

颜色分类
前 K 个高频元素
数组中的第 K 个最大元素
寻找峰值
在排序数组中查找元素的第一个和最后一个位置
合并区间
搜索旋转排序数组
搜索二维矩阵 II

## 动态规划

跳跃游戏
不同路径
零钱兑换
最长递增子序列

## 设计问题

二叉树的序列化与反序列化
常数时间插入、删除和获取随机元素

## 数学

快乐数
阶乘后的零
Excel 表列序号
Pow(x, n)
x 的平方根
两数相除
分数到小数

## 其他

两整数之和
逆波兰表达式求值
多数元素
任务调度器
